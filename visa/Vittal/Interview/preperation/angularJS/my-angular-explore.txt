ngModelOptions:
-directive in ng module 
Related to form operation and any changes in the form will trigger the event to update the view-->Model and vice versa and to disturb this flow 
we have to include noModelOptions
----------------------------------------------------
ngClick and ngSubmit
Note that ngClick events will occur before the model is updated. Use ngSubmit to have access to the updated model.
--------------------------------------------------
ng-submit
use this directive like below 
<form class="form-horizontal" name='form' novalidate ng-submit="update(user)">

it is form attribute to submit a form and be aware about ng-click for button of type submit, there is chances to use both
--------------------------------------------
ng-model-options =object
ng-model-options={updateOn:'blur'}

this directive is used for updating the model to view can be alter by immediate update using following object
<input type='text' ng-model-options={updateOn:'blur',debounce:{'default':500,'blur':0}} />

the data which enters within the above text will update the model once it lost it focus and after 500ms delay

About Directive: Difference between compile funtion and link function in directive
Directive Parameters:
priority:$scompiler method will sort directies based on the priority so we informing to $compiler to sort this directive with high priority
transclude:
link:
compile:

http://www.ng-newsletter.com/posts/directives.html
When the DOM is done loading and the AngularJS process starts booting up, the first process that happens is the HTML is parsed by the browser as a DOM tree. This tree is then parsed using AngularJS’s $compile() method. $compile runs through the DOM tree and looks for directive declarations for the different DOM elements. Once all directive declarations are found for each DOM element and sorted (by priority, which we’ll get into shortly), the directive’s compile function is run and is expected to return a link() function. The $compile() function will return a linking function that wraps all of the containing DOM element’s directives’ linking functions.

Finally, the linking function is invoked with the containing scope that attaches all of the associated directives to that scope. This is where we’ll do most of the work when building directives, as this is where we can register listeners, set up watches, and add functionality. The result of this process is why the live data-binding exists between the scope and the DOM tree.


Why have a compile and link function?
So why does AngularJS have two functions that run at the compile phase instead of just combining them into one? Boiled down, the answer is for performance. It’s slow to compile and interpolate against scopes every time a new directive of the same type is created. Because of this, all of the slow parts of the compilation process are front-loaded into the compile phase, while the linking happens when everything is associated and attached to the DOM.

In summary
We’ll use the compile function to both manipulate the DOM before it’s rendered and return a link function (that will handle the linking for us). This also is the place to put any methods that need to be shared around with all of the instances of this directive.

We’ll use the link function to register all listeners on a specific DOM element (that’s cloned from the template) and set up our bindings to the page.

----------------------------------------------
$validators:
Each function in the $validators object receives the MODELVALUE and the VIEWVALUE as parameters.

Failed validators are stored by key in ngModelController.$error

In-progress async validations are stored by key in ngModelController.$pending.

Additionally, there is the $asyncValidators object which handles asynchronous validation, such as making an $http request to the backend

---------------------------------------------------------------------------------------
When should I use an attribute versus an element? 

Use an element when you are creating a component that is in control of the template. The common case for this is when you are creating a Domain-Specific Language for parts of your template. 
Use an attribute when you are decorating an existing element with new functionality.
-------------------------------------------------------------------------
Services==Factory
Angular services are substitutable objects that are wired together using dependency injection (DI). You can use services to organize and share code across your app.
--Resuable code/methods across the application 
--Return value of the service is object or function can be injected to controller,service,filter or directive
--you can also register services via the $provide service inside of a module's config function:

------------------------------------------------------------------------------
$stateProvider and $state.go or UI-Router.
--After login success then landing to next page then use $state.go('state name which is defined in stateProvider')
--If you want to pass non-URL state, then you must not use url when setting up your state.
-- it changes view based on the state of the application and not just the URL
-- https://scotch.io/tutorials/angular-routing-using-ui-router
-- http://codepen.io/ahsx/pen/mDcEd

------------------------------------------------------------------------------------
$broadcast: 
It dispatches an event name downwards to all child scopes (and their children) and notify to the registered $rootScope.Scope listeners. The event life cycle starts at the scope on which $broadcast was called. All listeners for the event on this scope get notified. Afterwards, the event traverses downwards toward the child scopes and calls all registered listeners along the way. The event cannot be canceled.
-------------------------------------------------------------------------------
$emit : 
It dispatches an event name upwards through the scope hierarchy and notify to the registered $rootScope.Scope listeners. The event life cycle starts at the scope on which $emit was called. The event traverses upwards toward the root scope and calls all registered listeners along the way. The event will stop propagating if one of the listeners cancels it.
---------------------------------------------------------------
$on:
It listen on events of a given type. It can catch the event dispatched by $broadcast and $emit.
--------------------------------------------------------
$http.jsonp({})
To consume cross domain API 
https://docs.angularjs.org/api/ng/service/$http#jsonp
https://en.wikipedia.org/wiki/JSONP

--------------------------------------------------------------------------
$watch,$digest and $apply
http://tutorials.jenkov.com/angularjs/watch-digest-apply.html#digest
https://www.ng-book.com/p/The-Digest-Loop-and-apply/
We should never use $watch in a controller: It makes it difficult to test the controller.

Should write $watch function in directive
<input type='text' ng-model='full_name' myDirective />

.directive('myDirective',function(){
return{
		link:function(scope,elem,attr,ctrl){
			scope.$watch('full_name',function(new_val,old_val){
				//write necessary code
			});
		}	
	}

})



----------------------------------------------------------------
$resource and $http:
$http: is basically XHR request from XMLHttpRequest and it is for to make third party web service call.
$resource: is wraps on $http service and it is used for RESTFul API call with CRUD Http methods like POST,GET,DELETE and PUT
https://www.packtpub.com/packtlib/book/Web-Development/9781783553983/6/ch06lvl1sec37/The%20difference%20between%20$http%20and%20$resource

---------------------------------------------------------------------
$setValidity(validationErrorKey, isValid)
Used for password and confirm passwd check with directive

-----------------------------------------------------------------------
Digest CYCLE or DIGEST LOOP 
https://www.ng-book.com/p/The-Digest-Loop-and-apply/

----------------------------------------------------------------------
Double curley brasis are called binding expressions 
<div ng-app>
	<span>10+20 ={{10+20}}</span>
</div>
------------------------------------------------------
ng-src
Do not use src attribute for image tag while binding image to view because it will make 2 server/service request to get the data and displays 404 error in console. Instead you can use the ng-src and it helps in two way it can avoid 2 service request and 404 error 
https://www.youtube.com/watch?v=YY_-BB_lZDI&list=PL6n9fhu94yhWKHkcL7RJmmXyxkuFB3KSl#t=31.085961

----------------------------------------------------
ng-model :two way data binding 
if Model changes then will reflect in view through binding expressions i.e {{}}
What if view changed, will model will get update through binding expressions. NOOOO
So to make this happen we have to use ng-model .
https://www.youtube.com/watch?v=2QB1S5y5DIk&list=PL6n9fhu94yhWKHkcL7RJmmXyxkuFB3KSl#t=77.651527

------------------------------------------------------------------
ng-repeat and ng-init
$index,$parentIndex,
<ul ng-repeat="country in countries">
	<li>{{country}}</li>
	<ul ng-repeat="city in countries.cities">
		<li> {{city}}, Parent Index={{$parentIndex}} -- Index {{$index}}</li>
	</ul>
</ul>

OR 

<ul ng-repeat="country in countries" ng-init="parentIndex = $index">
	<li>{{country}}</li>
	<ul ng-repeat="city in countries.cities">
		<li> {{city}}, Parent Index={{parentIndex}} -- Index {{$index}}</li>
	</ul>
</ul>
----------------------------------------------------------------------------------
Why we have to use IIFE for each angularJS files(controller,services and directives)
Wrap Angular components in an Immediately Invoked Function Expression (IIFE).
1. IIFE removes global scope of variables and also avoids varible collisions  , which increases the security level 
2. We can create bundle JS file from all JS files in angularJS app 
IIFE(Immediately Invoked Function Expression) SELF INVOKING FUNCTIONS .
https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#iife

---------------------------------------------------
FILTERS 
:Filter can do Format,Sort and Filter the data 
SYNTAX
{{expression | filterName:parameter}}

Limitfilter 
{{exoression | limitTo : limit : begin}}

filters can be used with binding exoression or directive
<td>{{employee.salary | currency:"INR":3}}</td>
or 
<tr ng-repeat="employee in employees | limitTo : rowsToDisplay">

TO SORT 
use orderByFilter
: to sort the data you can use filters 
{{orderBy_expression | orderBy : expression : reverse}}
https://youtu.be/c4WAzFjJAzM?list=PL6n9fhu94yhWKHkcL7RJmmXyxkuFB3KSl

:You can use + or - to sort Ascedning or descending  the column of table using orderBy filter

-------------------------------------------------------------------------------


Why we have to use self invoking functions in angularJS app
Why?: An IIFE removes variables from the global scope. This helps prevent variables and function declarations from living longer than expected in the global scope, which also helps avoid variable collisions.

Why?: When your code is minified and bundled into a single file for deployment to a production server, you could have collisions of variables and many global variables. An IIFE protects you against both of these by providing variable scope for each file.

----------------------------------------------
Template Catching in AngularJS
https://docs.angularjs.org/api/ng/service/$templateCache

-----------------------------------------------------------------------------------------
Difference between AngularJS  SERVICE and FACTORY
http://blog.thoughtram.io/angular/2015/07/07/service-vs-factory-once-and-for-all.html
SERVICE:
1.a service is a constructor function
2. No need return an object from service 
3. In service Object.create() will use in angular lib code that is the reason we have to "this" keyword 
4. Service internally calls factory 
FACTORY
1. FACTORY is not constructor function 
2. Factory function is really just a function that gets called, which is why we have to return an object explicitly.
3. We should return an object


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ UNIT TESTING @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
$httpBackend
Test REST API code with $httpBackend
FLUSH method 
The $httpBackend used in production always responds to requests asynchronously. If we preserved this behavior in unit testing, we'd have to create async unit tests, which are hard to write, to follow and to maintain. But neither can the testing mock respond synchronously; that would change the execution of the code under test. For this reason, the mock $httpBackend has a flush() method, which allows the test to explicitly flush pending requests. This preserves the async api of the backend, while allowing the test to execute synchronously.
---------------------------------------------------------------------------------
UI-ROuter and Ng-Router Difference 
http://www.amasik.com/angularjs-ngroute-vs-ui-router/
About: ui-router https://github.com/angular-ui/ui-router/wiki/Quick-Reference
https://scotch.io/tutorials/3-simple-tips-for-using-ui-router





-------------------------------------------------------
My DOUBTS
-------------------------------------------------------
1. difference between controller and controllerAs	
--> we can create object of that scope to communicate with controller and increased code maintainance.
Directly we can access the eintre object called customer which contains all scope fileds value  
<div ng-controller="CustomerController as customer">
    {{ customer.name }}
</div>

<!-- avoid -->
<div ng-controller="CustomerController">
    {{ name }}
</div>

2. How to share the data between directives
3. How to pass data between states controller while changing states 
4. What is the anugalarJS abstract states 
5. What is $interpolate and $interceptor 
--------------------------------------------------------------------
NOTE:
--------------------------------------------------------------------
1. AngularJS version and Angular-MockJS version shuold be same


ANGULARJS SECURITY
$sce : Strict Contextual Escaping 
$sce.trustAsHTML
$sce.trustAs(type,val)
$sce.trustAsUrl(val)
$sce.trustAsResourceUrl(value);
$sce.trustAsJs(value);


Best Practises:
1.	Use ng-src in place of src for images : Following 
2.	Use promise for handling call-backs. AngularJS has exposed “$q” service for it. A number of AngularJS services return promises: $http, $interval, $timeout. : Following 
3.	Do not minify angular.min.js because as per AngularJS team they has minified angular files with predefined settings, which may break if we minify again. So just concatenate it. : Following 
4.	Use $templateCache to cache html templates, if template caching is required: Following
5.	Always wrap 3rd party API call-backs in to $apply to notify AngularJS regarding out of environment changes.: We have not encountered this situation yet so far
6.	If we don’t want user to show our HTML until AngularJS has loaded, use ng-cloak directive.
<div class="session ng-cloak">..............content............</div>
.ng-cloak {
/* this will change to block when scope and angular is ready */
display:none;
}
7.	Don’t use “ng” prefix for our directives to avoid any collisions. Create your custom one.Better to use <my–component> because <my:component> sometimes breaks on IE. : Following 
8.	Use $broadcast() , $emit() and $on() for events of  global relevance across the app (such as a user authenticating or the app closing). : Following 
9.	If we need events specific to modules, services or widgets we should opt for Services, Directive Controllers etc. : Following 
10.	Don’t use self-closing tag because some browsers don’t like them. Use “<product-title></product-title >” rather than “<product-title/>”. : Have to check HTML code

















@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ANGULAR 2.0 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Cheatsheet 
https://angular.io/docs/ts/latest/guide/cheatsheet.html
About Template
https://angular.io/docs/ts/latest/guide/template-syntax.html


NOTES:
Angular2 deals with follo 8 parameters 
1.Module
2. Component
3. Template
4. Metadata
5. Data Binding
6. Directive
7. Service
8. Dependency Injection

Metadata:
Metadata tells Angular how to process a class.

DECOARATERS:
@component({metadata}),@Injectable, @Input, @Output, @RouterConfig
@Component({
  selector:    'hero-list',
  templateUrl: 'app/hero-list.component.html',
  directives:  [HeroDetailComponent],
  providers:   [HeroService]
})

DIRECTIVES:
There are two other kinds of directives as well that we call "structural" and "attribute" directives.

Services:
Have to handle fetch data from server,validate input field,Application Logic 
Services are available to component using dependency injection 

COMPONENTS:
This guy job to enable the USER EXPeriance and nothing more 
A good component presents properties and methods for data binding. It delegates everything non-trivial to services.
Component are depend on Service for all 

TESTING :
https://angular.io/docs/ts/latest/guide/testing.html


KeyNotes:
--------------------------------------------------------------------------------------
Example: <button [disabled]="inputElement.value==='yes'"></button>
[] COMPONENT-->VIEW means 
() VIEW     ---> COMPOENENT
[()] --> Two way data binding 

------------------------------------------------------------------------------------
Here RxJS is responsible for making async call via REST API 
1. the angular http.get returns an RxJS Obesrvable 
2. Observables are a powerful way to manage asynchronous data flows 
3. 





ROUTER:
The Component Router is a service. Like any service, we have to import it and make it available to the application by adding it to the providers array.


UNIT TESTING :
https://medium.com/google-developer-experts/angular-2-unit-testing-with-jasmine-defe20421584#.s46rstz1b

Communication b/w Component or handshake b/w component 
https://angular.io/docs/ts/latest/cookbook/component-communication.html#!#child-to-parent




